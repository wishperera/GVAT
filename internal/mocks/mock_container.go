// Code generated by MockGen. DO NOT EDIT.
// Source: ./container.go

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	domain "github.com/wishperera/GVAT/internal/domain"
)

// MockContainer is a mock of Container interface.
type MockContainer struct {
	ctrl     *gomock.Controller
	recorder *MockContainerMockRecorder
}

// MockContainerMockRecorder is the mock recorder for MockContainer.
type MockContainerMockRecorder struct {
	mock *MockContainer
}

// NewMockContainer creates a new mock instance.
func NewMockContainer(ctrl *gomock.Controller) *MockContainer {
	mock := &MockContainer{ctrl: ctrl}
	mock.recorder = &MockContainerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContainer) EXPECT() *MockContainerMockRecorder {
	return m.recorder
}

// Bind mocks base method.
func (m *MockContainer) Bind(name string, value interface{}) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Bind", name, value)
}

// Bind indicates an expected call of Bind.
func (mr *MockContainerMockRecorder) Bind(name, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Bind", reflect.TypeOf((*MockContainer)(nil).Bind), name, value)
}

// GetModuleConfig mocks base method.
func (m *MockContainer) GetModuleConfig(name string) domain.Config {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetModuleConfig", name)
	ret0, _ := ret[0].(domain.Config)
	return ret0
}

// GetModuleConfig indicates an expected call of GetModuleConfig.
func (mr *MockContainerMockRecorder) GetModuleConfig(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetModuleConfig", reflect.TypeOf((*MockContainer)(nil).GetModuleConfig), name)
}

// Init mocks base method.
func (m *MockContainer) Init(modules ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range modules {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Init", varargs...)
}

// Init indicates an expected call of Init.
func (mr *MockContainerMockRecorder) Init(modules ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockContainer)(nil).Init), modules...)
}

// Resolve mocks base method.
func (m *MockContainer) Resolve(name string) interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resolve", name)
	ret0, _ := ret[0].(interface{})
	return ret0
}

// Resolve indicates an expected call of Resolve.
func (mr *MockContainerMockRecorder) Resolve(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resolve", reflect.TypeOf((*MockContainer)(nil).Resolve), name)
}

// MockAppContainer is a mock of AppContainer interface.
type MockAppContainer struct {
	ctrl     *gomock.Controller
	recorder *MockAppContainerMockRecorder
}

// MockAppContainerMockRecorder is the mock recorder for MockAppContainer.
type MockAppContainerMockRecorder struct {
	mock *MockAppContainer
}

// NewMockAppContainer creates a new mock instance.
func NewMockAppContainer(ctrl *gomock.Controller) *MockAppContainer {
	mock := &MockAppContainer{ctrl: ctrl}
	mock.recorder = &MockAppContainerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAppContainer) EXPECT() *MockAppContainerMockRecorder {
	return m.recorder
}

// Bind mocks base method.
func (m *MockAppContainer) Bind(name string, value interface{}) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Bind", name, value)
}

// Bind indicates an expected call of Bind.
func (mr *MockAppContainerMockRecorder) Bind(name, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Bind", reflect.TypeOf((*MockAppContainer)(nil).Bind), name, value)
}

// GetModuleConfig mocks base method.
func (m *MockAppContainer) GetModuleConfig(name string) domain.Config {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetModuleConfig", name)
	ret0, _ := ret[0].(domain.Config)
	return ret0
}

// GetModuleConfig indicates an expected call of GetModuleConfig.
func (mr *MockAppContainerMockRecorder) GetModuleConfig(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetModuleConfig", reflect.TypeOf((*MockAppContainer)(nil).GetModuleConfig), name)
}

// Init mocks base method.
func (m *MockAppContainer) Init(modules ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range modules {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Init", varargs...)
}

// Init indicates an expected call of Init.
func (mr *MockAppContainerMockRecorder) Init(modules ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockAppContainer)(nil).Init), modules...)
}

// Resolve mocks base method.
func (m *MockAppContainer) Resolve(name string) interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resolve", name)
	ret0, _ := ret[0].(interface{})
	return ret0
}

// Resolve indicates an expected call of Resolve.
func (mr *MockAppContainerMockRecorder) Resolve(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resolve", reflect.TypeOf((*MockAppContainer)(nil).Resolve), name)
}

// SetModuleConfig mocks base method.
func (m *MockAppContainer) SetModuleConfig(name string, value domain.Config) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetModuleConfig", name, value)
}

// SetModuleConfig indicates an expected call of SetModuleConfig.
func (mr *MockAppContainerMockRecorder) SetModuleConfig(name, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetModuleConfig", reflect.TypeOf((*MockAppContainer)(nil).SetModuleConfig), name, value)
}

// ShutDown mocks base method.
func (m *MockAppContainer) ShutDown(modules ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range modules {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "ShutDown", varargs...)
}

// ShutDown indicates an expected call of ShutDown.
func (mr *MockAppContainerMockRecorder) ShutDown(modules ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShutDown", reflect.TypeOf((*MockAppContainer)(nil).ShutDown), modules...)
}

// Start mocks base method.
func (m *MockAppContainer) Start(modules ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range modules {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Start", varargs...)
}

// Start indicates an expected call of Start.
func (mr *MockAppContainerMockRecorder) Start(modules ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockAppContainer)(nil).Start), modules...)
}

// MockRunnable is a mock of Runnable interface.
type MockRunnable struct {
	ctrl     *gomock.Controller
	recorder *MockRunnableMockRecorder
}

// MockRunnableMockRecorder is the mock recorder for MockRunnable.
type MockRunnableMockRecorder struct {
	mock *MockRunnable
}

// NewMockRunnable creates a new mock instance.
func NewMockRunnable(ctrl *gomock.Controller) *MockRunnable {
	mock := &MockRunnable{ctrl: ctrl}
	mock.recorder = &MockRunnableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRunnable) EXPECT() *MockRunnableMockRecorder {
	return m.recorder
}

// Ready mocks base method.
func (m *MockRunnable) Ready() chan struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ready")
	ret0, _ := ret[0].(chan struct{})
	return ret0
}

// Ready indicates an expected call of Ready.
func (mr *MockRunnableMockRecorder) Ready() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ready", reflect.TypeOf((*MockRunnable)(nil).Ready))
}

// Run mocks base method.
func (m *MockRunnable) Run() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run")
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockRunnableMockRecorder) Run() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockRunnable)(nil).Run))
}

// MockStoppable is a mock of Stoppable interface.
type MockStoppable struct {
	ctrl     *gomock.Controller
	recorder *MockStoppableMockRecorder
}

// MockStoppableMockRecorder is the mock recorder for MockStoppable.
type MockStoppableMockRecorder struct {
	mock *MockStoppable
}

// NewMockStoppable creates a new mock instance.
func NewMockStoppable(ctrl *gomock.Controller) *MockStoppable {
	mock := &MockStoppable{ctrl: ctrl}
	mock.recorder = &MockStoppableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStoppable) EXPECT() *MockStoppableMockRecorder {
	return m.recorder
}

// Stop mocks base method.
func (m *MockStoppable) Stop() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop")
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockStoppableMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockStoppable)(nil).Stop))
}
